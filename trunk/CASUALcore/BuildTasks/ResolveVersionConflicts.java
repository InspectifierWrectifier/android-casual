/*ResolveVersionConflicts provides a method of resolving Build  revision problems
 *Copyright (C) 2015  Adam Outler
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see https://www.gnu.org/licenses/ .
 */
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;

/**
 *ResolveBuildConflicts provides a method of resolving Build revision problems
 * @author Adam Outler adamoutler@gmail.com
 */
public class ResolveVersionConflicts {

    /**
     * resolves problems in Build
     *
     * @param args the path to the conflicting CASUALApp files
     */
    public static void main(String[] args){
        String path = args[0];
        File folder = new File(path);
        int casualAppCount = 0;
        int highestBuildNumber = 0;
        Properties casualAppProp = new Properties();
        String casAppPath = path + "CASUALApp.properties";
        try {
            casualAppProp.load(new FileInputStream(casAppPath));
        } catch (IOException ex) {
            return;
        }

        for (String f : folder.list()) {
            if (f.contains("CASUALApp.properties")) {
                casualAppCount++;
                Properties prop = new Properties();
                try {
                    System.out.println("loading: "+ path + "/" + f);
                    FileInputStream fis = new FileInputStream(path + "/" + f);
                    prop.load(fis);
                    
                    String buildStr = prop.getProperty("Application.buildnumber");
                    highestBuildNumber = testValueForHigher(highestBuildNumber, prop, "Application.buildnumber");
                    
                } catch (FileNotFoundException ex) {
                    return;
                } catch (IOException ex) {
                    return;
                }

            }
        }
        if (casualAppCount > 1) {
            System.out.println("there are multiple metas.  merging and cleaning.\nStoring the true " + casAppPath);
            if (highestBuildNumber > 1) {
                casualAppProp.setProperty("Application.buildnumber", Integer.toString(highestBuildNumber));
                System.out.println("new Application.buildnumber=" + casualAppProp.getProperty("Application.buildnumber"));
            }
            casualAppProp.remove("");
            casualAppProp.remove("<<<<<<<");
            casualAppProp.remove(">>>>>>>");


            /*try {
             } catch (IOException ex) {
             return;
             }*/
            for (String f : folder.list()) {
                if (f.contains("CASUALApp.properties")) {
                    if (!(new File(f).getName().equals("CASUALApp.properties"))) {
                        File del= new File(path + f);
                        System.out.println("removing: "+ path + f +" "+ del.delete());
                    } else {
                        System.out.println("storing: " +path +  f);
                        try {
                            casualAppProp.store(new FileOutputStream(casAppPath), "Properties file generated by BuildTasks/ResolveBuildConflics during build time.\nIf you are having problems with this file, ensure that there are no Git conflicts prior to setting values.");
                        } catch (FileNotFoundException ex) {
                            return;
                        } catch (IOException ex) {
                            return;
                        }

                    }
                }
            }
        }
    }

    private static int testValueForHigher(int highNumber, Properties prop, String property) {
        String testValue = prop.getProperty(property).replace(",", "");

        if (Integer.parseInt(testValue) > 0) {
            int testInt = Integer.parseInt(testValue);
            if (testInt > highNumber) {
                return testInt;
            }
        }
        return highNumber;
    }
}
